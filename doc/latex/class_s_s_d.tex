\hypertarget{class_s_s_d}{}\section{S\+SD Class Reference}
\label{class_s_s_d}\index{S\+SD@{S\+SD}}


{\ttfamily \#include $<$S\+S\+D.\+h$>$}



Collaboration diagram for S\+SD\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_s_s_d__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_s_s_d_ab89e65721f203d52f63b5e5d833d671c}{S\+SD}} (const std\+::string \&model\+\_\+file, const std\+::string \&trained\+\_\+file, const std\+::string \&mean\+\_\+file, const std\+::string \&mean\+\_\+value, const std\+::string \&label\+\_\+file, \mbox{\hyperlink{class_g_p_u_allocator}{G\+P\+U\+Allocator}} $\ast$allocator, float conf\+\_\+threshold)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_s_s_d}{S\+SD}} Constructor. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{_s_s_d_8h_a6145f2543054bcfbafc56318060f727b}{Detected\+B\+Boxes}} \mbox{\hyperlink{class_s_s_d_a35235278ff6d18ee494b2ccce3303c67}{Detect}} (const Mat \&img, int N=5)
\begin{DoxyCompactList}\small\item\em Forwarding \mbox{\hyperlink{class_s_s_d}{S\+SD}} with a image. \end{DoxyCompactList}\item 
virtual Mat \mbox{\hyperlink{class_s_s_d_a68c76ba1ebc94d222c1fd624db060f62}{Detect\+As\+Mat}} (const Mat \&img)
\begin{DoxyCompactList}\small\item\em Forwarding \mbox{\hyperlink{class_s_s_d}{S\+SD}} with a image. \end{DoxyCompactList}\item 
const std\+::vector$<$ std\+::string $>$ \& \mbox{\hyperlink{class_s_s_d_aca3c228118b686923b97cd120cf057c5}{Get\+Labels}} () const
\begin{DoxyCompactList}\small\item\em Return all labels. \end{DoxyCompactList}\item 
const std\+::string \& \mbox{\hyperlink{class_s_s_d_ac5c69f839f08bfa37dd33a66331f6fa3}{Get\+Label}} (size\+\_\+t idx) const
\begin{DoxyCompactList}\small\item\em Return a label by index. \end{DoxyCompactList}\item 
const cv\+::\+Size \& \mbox{\hyperlink{class_s_s_d_a20f17f5f9dbdc816f7b3ae4e30428427}{Get\+Input\+Geometry}} () const
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ std\+::vector$<$ float $>$ $>$ \mbox{\hyperlink{class_s_s_d_a58c0ef81b4b24424fd967d90da5c6045}{Predict}} (const Mat \&img)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_s_s_d_ada3debdd0e04185587f13b44a6b63765}{Set\+Mean}} (const std\+::string \&mean\+\_\+file, const std\+::string \&mean\+\_\+value)
\item 
void \mbox{\hyperlink{class_s_s_d_aec550d5312257216d93955cdee13a73e}{Wrap\+Input\+Layer}} (std\+::vector$<$ \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{Gpu\+Mat}} $>$ $\ast$input\+\_\+channels)
\item 
void \mbox{\hyperlink{class_s_s_d_a83cb8c64cda9b3792c5612613b56c828}{Preprocess}} (const Mat \&img, std\+::vector$<$ \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{Gpu\+Mat}} $>$ $\ast$input\+\_\+channels)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_g_p_u_allocator}{G\+P\+U\+Allocator}} $\ast$ \mbox{\hyperlink{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}{allocator\+\_\+}}
\item 
std\+::shared\+\_\+ptr$<$ caffe\+::\+Net$<$ float $>$ $>$ \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\+\_\+}}
\item 
Size \mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\+\_\+geometry\+\_\+}}
\item 
int \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\+\_\+channels\+\_\+}}
\item 
\mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{Gpu\+Mat}} \mbox{\hyperlink{class_s_s_d_a3974a4a620cee93f5523c459482887e2}{mean\+\_\+}}
\item 
std\+::vector$<$ std\+::string $>$ \mbox{\hyperlink{class_s_s_d_a1c4d34f2dda5d4ca2dfabbebff7a0ddb}{labels\+\_\+}}
\item 
float \mbox{\hyperlink{class_s_s_d_a2deab37585140ff74fbec6e54f5407bf}{conf\+\_\+}}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 94 of file S\+S\+D.\+h.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_s_s_d_ab89e65721f203d52f63b5e5d833d671c}\label{class_s_s_d_ab89e65721f203d52f63b5e5d833d671c}} 
\index{S\+SD@{S\+SD}!S\+SD@{S\+SD}}
\index{S\+SD@{S\+SD}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{S\+S\+D()}{SSD()}}
{\footnotesize\ttfamily S\+S\+D\+::\+S\+SD (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{model\+\_\+file,  }\item[{const std\+::string \&}]{trained\+\_\+file,  }\item[{const std\+::string \&}]{mean\+\_\+file,  }\item[{const std\+::string \&}]{mean\+\_\+value,  }\item[{const std\+::string \&}]{label\+\_\+file,  }\item[{\mbox{\hyperlink{class_g_p_u_allocator}{G\+P\+U\+Allocator}} $\ast$}]{allocator,  }\item[{float}]{conf\+\_\+threshold }\end{DoxyParamCaption})}



\mbox{\hyperlink{class_s_s_d}{S\+SD}} Constructor. 


\begin{DoxyParams}{Parameters}
{\em model\+\_\+file} & deploy prototxt path \\
\hline
{\em trained\+\_\+file} & caffemodel prototxt path \\
\hline
{\em mean\+\_\+file} & \char`\"{}\char`\"{} or mean binaryproto file path \\
\hline
{\em mean\+\_\+value} & \char`\"{}104,117,123\char`\"{} -\/ Use this parameter if not having a mean file \\
\hline
{\em label\+\_\+file} & labelmap prototxt path \\
\hline
{\em allocator} & Instance of \mbox{\hyperlink{class_g_p_u_allocator}{G\+P\+U\+Allocator}} \\
\hline
{\em iou\+\_\+threshold} & I\+OU threshold value \\
\hline
{\em ios\+\_\+threshold} & I\+OS threshold value \\
\hline
{\em conf\+\_\+threshold} & Confidence threshold value \\
\hline
\end{DoxyParams}


Definition at line 14 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
21     : \mbox{\hyperlink{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}{allocator\_}}(allocator),
22       \mbox{\hyperlink{class_s_s_d_a2deab37585140ff74fbec6e54f5407bf}{conf\_}}(conf\_threshold)
23 \{
24     LOG(INFO) << \mbox{\hyperlink{class_s_s_d_a2deab37585140ff74fbec6e54f5407bf}{conf\_}};
25     Caffe::set\_mode(Caffe::GPU);
26 
27     \textcolor{comment}{/* Load the network. */}
28     \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}} = std::make\_shared<Net<float>>(model\_file, TEST);
29     \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->CopyTrainedLayersFrom(trained\_file);
30 
31     CHECK\_EQ(\mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->num\_inputs(), 1) << \textcolor{stringliteral}{"Network should have exactly one input."};
32     CHECK\_EQ(\mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->num\_outputs(), 1) << \textcolor{stringliteral}{"Network should have exactly one output."};
33 
34     Blob<float>* input\_layer = \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->input\_blobs()[0];
35     \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} = input\_layer->channels();
36     CHECK(\mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 3 || \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 1)
37         << \textcolor{stringliteral}{"Input layer should have 1 or 3 channels."};
38     \mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}} = Size(input\_layer->width(), input\_layer->height());
39 
40     \textcolor{comment}{/* Load the binaryproto mean file. */}
41     \mbox{\hyperlink{class_s_s_d_ada3debdd0e04185587f13b44a6b63765}{SetMean}}(mean\_file, mean\_value);
42 
43     \textcolor{comment}{/* Load labels. */}
44     LabelMap labelMap;
45 \textcolor{preprocessor}{#if defined (\_MSC\_VER)  // for MSC compiler binary flag needs to be specified}
46     \textcolor{keywordtype}{int} fd;
47     \_sopen\_s(&fd, label\_file.c\_str(), O\_RDONLY | O\_BINARY, \_SH\_DENYNO, 0);
48 \textcolor{preprocessor}{#else}
49     \textcolor{keywordtype}{int} fd = open(filename, O\_RDONLY);
50 \textcolor{preprocessor}{#endif}
51     CHECK\_NE(fd, -1) << \textcolor{stringliteral}{"Unable to open labels file "} << label\_file;
52     google::protobuf::io::FileInputStream fileInput(fd);
53     fileInput.SetCloseOnDelete(\textcolor{keyword}{true});
54     CHECK(google::protobuf::TextFormat::Parse(&fileInput, &labelMap)) << \textcolor{stringliteral}{"Parse failed from: "} << 
      label\_file;
55     
56     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < labelMap.item\_size(); ++i)
57     \{
58         \textcolor{keyword}{const} LabelMapItem& item = labelMap.item(i);
59         \mbox{\hyperlink{class_s_s_d_a1c4d34f2dda5d4ca2dfabbebff7a0ddb}{labels\_}}.push\_back(item.display\_name());
60     \}
61 
63     \textcolor{comment}{//Retrive labels}
65 \textcolor{comment}{}    \textcolor{comment}{/*if (!labels\_.empty())}
66 \textcolor{comment}{    \{}
67 \textcolor{comment}{        std::ofstream ostream("labels.txt");}
68 \textcolor{comment}{        CHECK(ostream.is\_open()) << "labels.txt isn't open";}
69 \textcolor{comment}{        for (size\_t i = 0; i < labels\_.size(); ++i)}
70 \textcolor{comment}{        \{}
71 \textcolor{comment}{            ostream << i << " " << labels\_[i] << std::endl;}
72 \textcolor{comment}{        \}}
73 \textcolor{comment}{        ostream.close();}
74 \textcolor{comment}{    \}*/}
75 
76     CHECK\_EQ(\mbox{\hyperlink{class_s_s_d_a1c4d34f2dda5d4ca2dfabbebff7a0ddb}{labels\_}}.size(), \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->layer\_by\_name(\textcolor{stringliteral}{"detection\_out"})->layer\_param().
      detection\_output\_param().num\_classes())
77         << \textcolor{stringliteral}{"Number of labels is different from the output layer's parameter."};
78 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=261pt]{class_s_s_d_ab89e65721f203d52f63b5e5d833d671c_cgraph}
\end{center}
\end{figure}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_s_s_d_a35235278ff6d18ee494b2ccce3303c67}\label{class_s_s_d_a35235278ff6d18ee494b2ccce3303c67}} 
\index{S\+SD@{S\+SD}!Detect@{Detect}}
\index{Detect@{Detect}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Detect()}{Detect()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_s_s_d_8h_a6145f2543054bcfbafc56318060f727b}{Detected\+B\+Boxes}} S\+S\+D\+::\+Detect (\begin{DoxyParamCaption}\item[{const Mat \&}]{img,  }\item[{int}]{N = {\ttfamily 5} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Forwarding \mbox{\hyperlink{class_s_s_d}{S\+SD}} with a image. 

This function is not used with Multi\+Target-\/\+Tracker due to return type The reason why I didn\textquotesingle{}t overloading is to follow \href{https://docs.google.com/document/d/1cT8EPgMXe0eopeHvwuFmbHG4TJr5kUmcovkr5irQZmo/edit#heading=h.r5zmbif4dbnf}{\tt popetv\textquotesingle{}s coding standards} I love his coding philosophy personally

\begin{DoxySince}{Since}
\href{https://github.com/Shinung/gpu-rest-engine/blob/ssd_gre/caffe_ssd/SSD.h}{\tt forked G\+R\+E/\+S\+S\+D.\+h} 
\end{DoxySince}

\begin{DoxyParams}{Parameters}
{\em img} & Decoding image to cv\+::\+Mat \\
\hline
{\em N} & Limit number of detecting objects \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Detected\+B\+Boxes 
\end{DoxyReturn}
\begin{DoxyAuthor}{Author}
Shinung 
\end{DoxyAuthor}


Definition at line 101 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
102 \{
103     Size frameSize(img.cols, img.rows);
104     std::vector< std::vector<float> > output = \mbox{\hyperlink{class_s_s_d_a58c0ef81b4b24424fd967d90da5c6045}{Predict}}(img);
105 
106     N = N <= 0 ? output.size() : std::min<int>(output.size(), N);
107     std::vector<int> maxN = \mbox{\hyperlink{_s_s_d_8cpp_a9ad3e3d3a4acacc7312fe108b8de242a}{Argmax}}(output, N);
108     \mbox{\hyperlink{_s_s_d_8h_a6145f2543054bcfbafc56318060f727b}{DetectedBBoxes}} detectedBoxes;
109     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < N; ++i)
110     \{
111         \textcolor{keywordtype}{int} idx = maxN[i];
112         detectedBoxes.emplace\_back(output[idx], \mbox{\hyperlink{class_s_s_d_a1c4d34f2dda5d4ca2dfabbebff7a0ddb}{labels\_}}[cvRound(output[idx][1])], frameSize);
113     \}
114 
115     \textcolor{keywordflow}{return} detectedBoxes;
116 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_s_s_d_a35235278ff6d18ee494b2ccce3303c67_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_s_s_d_a68c76ba1ebc94d222c1fd624db060f62}\label{class_s_s_d_a68c76ba1ebc94d222c1fd624db060f62}} 
\index{S\+SD@{S\+SD}!Detect\+As\+Mat@{Detect\+As\+Mat}}
\index{Detect\+As\+Mat@{Detect\+As\+Mat}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Detect\+As\+Mat()}{DetectAsMat()}}
{\footnotesize\ttfamily Mat S\+S\+D\+::\+Detect\+As\+Mat (\begin{DoxyParamCaption}\item[{const Mat \&}]{img }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Forwarding \mbox{\hyperlink{class_s_s_d}{S\+SD}} with a image. 


\begin{DoxyParams}{Parameters}
{\em img} & Decoding image to cv\+::\+Mat \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cv\+::\+Mat that has raw results from \mbox{\hyperlink{class_s_s_d}{S\+SD}} instead of Detected\+B\+Boxes 
\end{DoxyReturn}
\begin{DoxyAuthor}{Author}
Shinung 
\end{DoxyAuthor}


Definition at line 118 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
119 \{
120     std::vector< std::vector<float> > output = \mbox{\hyperlink{class_s_s_d_a58c0ef81b4b24424fd967d90da5c6045}{Predict}}(img);
121     cv::Mat detections(output.size(), 7, CV\_32F);
122 
123     \textcolor{keywordtype}{int} r = 0;
124     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} objInfo : output)
125     \{
126         cv::Mat obj(1, objInfo.size(), CV\_32F, objInfo.data());
127         obj.copyTo(detections.row(r));
128         r++;
129     \}
130 
131     \textcolor{keywordflow}{return} detections;
132 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_s_s_d_a68c76ba1ebc94d222c1fd624db060f62_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_s_s_d_a68c76ba1ebc94d222c1fd624db060f62_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_s_s_d_a20f17f5f9dbdc816f7b3ae4e30428427}\label{class_s_s_d_a20f17f5f9dbdc816f7b3ae4e30428427}} 
\index{S\+SD@{S\+SD}!Get\+Input\+Geometry@{Get\+Input\+Geometry}}
\index{Get\+Input\+Geometry@{Get\+Input\+Geometry}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Get\+Input\+Geometry()}{GetInputGeometry()}}
{\footnotesize\ttfamily const cv\+::\+Size \& S\+S\+D\+::\+Get\+Input\+Geometry (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

\begin{DoxyReturn}{Returns}
Size of input layer of \mbox{\hyperlink{class_s_s_d}{S\+SD}} 
\end{DoxyReturn}
\begin{DoxyAuthor}{Author}
Shinung 
\end{DoxyAuthor}


Definition at line 144 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
145 \{
146     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}};
147 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_s_s_d_a20f17f5f9dbdc816f7b3ae4e30428427_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_s_s_d_ac5c69f839f08bfa37dd33a66331f6fa3}\label{class_s_s_d_ac5c69f839f08bfa37dd33a66331f6fa3}} 
\index{S\+SD@{S\+SD}!Get\+Label@{Get\+Label}}
\index{Get\+Label@{Get\+Label}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Get\+Label()}{GetLabel()}}
{\footnotesize\ttfamily const std\+::string \& S\+S\+D\+::\+Get\+Label (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{idx }\end{DoxyParamCaption}) const}



Return a label by index. 

\begin{DoxyReturn}{Returns}
label string 
\end{DoxyReturn}
\begin{DoxyAuthor}{Author}
Shinung 
\end{DoxyAuthor}


Definition at line 139 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
140 \{
141     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_s_s_d_a1c4d34f2dda5d4ca2dfabbebff7a0ddb}{labels\_}}[idx];
142 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_s_s_d_ac5c69f839f08bfa37dd33a66331f6fa3_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_s_s_d_aca3c228118b686923b97cd120cf057c5}\label{class_s_s_d_aca3c228118b686923b97cd120cf057c5}} 
\index{S\+SD@{S\+SD}!Get\+Labels@{Get\+Labels}}
\index{Get\+Labels@{Get\+Labels}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Get\+Labels()}{GetLabels()}}
{\footnotesize\ttfamily const std\+::vector$<$ std\+::string $>$ \& S\+S\+D\+::\+Get\+Labels (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return all labels. 

\begin{DoxyReturn}{Returns}
std\+::vector of labels 
\end{DoxyReturn}
\begin{DoxyAuthor}{Author}
Shinung 
\end{DoxyAuthor}


Definition at line 134 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
135 \{
136     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_s_s_d_a1c4d34f2dda5d4ca2dfabbebff7a0ddb}{labels\_}};
137 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_s_s_d_a58c0ef81b4b24424fd967d90da5c6045}\label{class_s_s_d_a58c0ef81b4b24424fd967d90da5c6045}} 
\index{S\+SD@{S\+SD}!Predict@{Predict}}
\index{Predict@{Predict}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Predict()}{Predict()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::vector$<$ float $>$ $>$ S\+S\+D\+::\+Predict (\begin{DoxyParamCaption}\item[{const Mat \&}]{img }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 149 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
150 \{
151     Blob<float>* input\_layer = \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->input\_blobs()[0];
152     input\_layer->Reshape(1, \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}},
153                          \mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}}.height, \mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}}.width);
154     \textcolor{comment}{/* Forward dimension change to all layers. */}
155     \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->Reshape();
156 
157     std::vector<GpuMat> input\_channels;
158     \mbox{\hyperlink{class_s_s_d_aec550d5312257216d93955cdee13a73e}{WrapInputLayer}}(&input\_channels);
159 
160     \mbox{\hyperlink{class_s_s_d_a83cb8c64cda9b3792c5612613b56c828}{Preprocess}}(img, &input\_channels);
161 
162     \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->Forward();
163 
164     \textcolor{comment}{/* Copy the output layer to a std::vector */}
165     Blob<float>* output\_layer = \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->output\_blobs()[0];
166     \textcolor{keyword}{const} \textcolor{keywordtype}{float}* result = output\_layer->cpu\_data();
167     \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_det = output\_layer->height();
168     std::vector< std::vector<float> > detections;
169     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k = 0; k < num\_det; ++k)
170     \{
171         \textcolor{keywordflow}{if}(result[1] < \mbox{\hyperlink{class_s_s_d_a2deab37585140ff74fbec6e54f5407bf}{conf\_}})
172         \{
173             \textcolor{comment}{//Skip invalid detection.}
174             result += 7;
175             \textcolor{keywordflow}{continue};
176         \}
177         vector<float> detection(result, result + 7);
178         detections.push\_back(detection);
179         result += 7;
180     \}
181 
182     \textcolor{keywordflow}{return} detections;
183 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=301pt]{class_s_s_d_a58c0ef81b4b24424fd967d90da5c6045_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_s_s_d_a58c0ef81b4b24424fd967d90da5c6045_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_s_s_d_a83cb8c64cda9b3792c5612613b56c828}\label{class_s_s_d_a83cb8c64cda9b3792c5612613b56c828}} 
\index{S\+SD@{S\+SD}!Preprocess@{Preprocess}}
\index{Preprocess@{Preprocess}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Preprocess()}{Preprocess()}}
{\footnotesize\ttfamily void S\+S\+D\+::\+Preprocess (\begin{DoxyParamCaption}\item[{const Mat \&}]{img,  }\item[{std\+::vector$<$ \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{Gpu\+Mat}} $>$ $\ast$}]{input\+\_\+channels }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 269 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
271 \{
272     \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{GpuMat}} img(host\_img, \mbox{\hyperlink{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}{allocator\_}});
273     \textcolor{comment}{/* Convert the input image to the input image format of the network. */}
274     \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{GpuMat}} sample(\mbox{\hyperlink{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}{allocator\_}});
275 
276 \textcolor{preprocessor}{#if (CV\_MAJOR\_VERSION > 3)}
277     \textcolor{keywordflow}{if} (img.channels() == 3 && \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 1)
278         cuda::cvtColor(img, sample, COLOR\_BGR2GRAY);
279     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (img.channels() == 4 && \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 1)
280         cuda::cvtColor(img, sample, COLOR\_BGR2GRAY);
281     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (img.channels() == 4 && \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 3)
282         cuda::cvtColor(img, sample, COLOR\_BGRA2BGR);
283     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (img.channels() == 1 && \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 3)
284         cuda::cvtColor(img, sample, COLOR\_GRAY2BGR);
285     \textcolor{keywordflow}{else}
286         sample = img;
287 \textcolor{preprocessor}{#else}
288     \textcolor{keywordflow}{if} (img.channels() == 3 && \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 1)
289         cuda::cvtColor(img, sample, CV\_BGR2GRAY);
290     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (img.channels() == 4 && \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 1)
291         cuda::cvtColor(img, sample, CV\_BGRA2GRAY);
292     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (img.channels() == 4 && \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 3)
293         cuda::cvtColor(img, sample, CV\_BGRA2BGR);
294     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (img.channels() == 1 && \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 3)
295         cuda::cvtColor(img, sample, CV\_GRAY2BGR);
296     \textcolor{keywordflow}{else}
297         sample = img;
298 \textcolor{preprocessor}{#endif}
299 
300     \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{GpuMat}} sample\_resized(\mbox{\hyperlink{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}{allocator\_}});
301     \textcolor{keywordflow}{if} (sample.size() != \mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}})
302         cuda::resize(sample, sample\_resized, \mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}});
303     \textcolor{keywordflow}{else}
304         sample\_resized = sample;
305 
306     \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{GpuMat}} sample\_float(\mbox{\hyperlink{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}{allocator\_}});
307     \textcolor{keywordflow}{if} (\mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}} == 3)
308         sample\_resized.convertTo(sample\_float, CV\_32FC3);
309     \textcolor{keywordflow}{else}
310         sample\_resized.convertTo(sample\_float, CV\_32FC1);
311 
312     \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{GpuMat}} sample\_normalized(\mbox{\hyperlink{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}{allocator\_}});
313     cuda::subtract(sample\_float, \mbox{\hyperlink{class_s_s_d_a3974a4a620cee93f5523c459482887e2}{mean\_}}, sample\_normalized);
314 
315     \textcolor{comment}{/* This operation will write the separate BGR planes directly to the}
316 \textcolor{comment}{     * input layer of the network because it is wrapped by the GpuMat}
317 \textcolor{comment}{     * objects in input\_channels. */}
318     cuda::split(sample\_normalized, *input\_channels);
319 
320     CHECK(reinterpret\_cast<float*>(input\_channels->at(0).data)
321           == \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->input\_blobs()[0]->gpu\_data())
322         << \textcolor{stringliteral}{"Input channels are not wrapping the input layer of the network."};
323 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_s_s_d_a83cb8c64cda9b3792c5612613b56c828_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_s_s_d_ada3debdd0e04185587f13b44a6b63765}\label{class_s_s_d_ada3debdd0e04185587f13b44a6b63765}} 
\index{S\+SD@{S\+SD}!Set\+Mean@{Set\+Mean}}
\index{Set\+Mean@{Set\+Mean}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Set\+Mean()}{SetMean()}}
{\footnotesize\ttfamily void S\+S\+D\+::\+Set\+Mean (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{mean\+\_\+file,  }\item[{const std\+::string \&}]{mean\+\_\+value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 186 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
187 \{
188     Scalar channel\_mean;
189     \textcolor{keywordflow}{if} (!mean\_file.empty())
190     \{
191         BlobProto blob\_proto;
192         ReadProtoFromBinaryFileOrDie(mean\_file.c\_str(), &blob\_proto);
193 
194         \textcolor{comment}{/* Convert from BlobProto to Blob<float> */}
195         Blob<float> mean\_blob;
196         mean\_blob.FromProto(blob\_proto);
197         CHECK\_EQ(mean\_blob.channels(), \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}})
198             << \textcolor{stringliteral}{"Number of channels of mean file doesn't match input layer."};
199 
200         \textcolor{comment}{/* The format of the mean file is planar 32-bit float BGR or grayscale. */}
201         std::vector<Mat> channels;
202         \textcolor{keywordtype}{float} *data = mean\_blob.mutable\_cpu\_data();
203         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}}; ++i)
204         \{
205             \textcolor{comment}{/* Extract an individual channel. */}
206             Mat channel(mean\_blob.height(), mean\_blob.width(), CV\_32FC1, data);
207             channels.push\_back(channel);
208             data += mean\_blob.height() * mean\_blob.width();
209         \}
210 
211         \textcolor{comment}{/* Merge the separate channels into a single image. */}
212         Mat packed\_mean;
213         merge(channels, packed\_mean);
214 
215         \textcolor{comment}{/* Compute the global mean pixel value and create a mean image}
216 \textcolor{comment}{     * filled with this value. */}
217         channel\_mean = mean(packed\_mean);
218         Mat host\_mean = Mat(\mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}}, packed\_mean.type(), channel\_mean);
219         \mbox{\hyperlink{class_s_s_d_a3974a4a620cee93f5523c459482887e2}{mean\_}}.upload(host\_mean);
220     \}
221     \textcolor{keywordflow}{if} (!mean\_value.empty())
222     \{
223         CHECK(mean\_file.empty()) << \textcolor{stringliteral}{"Cannot specify mean\_file and mean\_value at the same time"};
224         stringstream ss(mean\_value);
225         vector<float> values;
226         \textcolor{keywordtype}{string} item;
227         \textcolor{keywordflow}{while} (getline(ss, item, \textcolor{charliteral}{','}))
228         \{
229             \textcolor{keywordtype}{float} \mbox{\hyperlink{struct_g_m_l__pair_aef8797e7d2fc0d2e2f628ce9c2783a6c}{value}} = std::atof(item.c\_str());
230             values.push\_back(\mbox{\hyperlink{struct_g_m_l__pair_aef8797e7d2fc0d2e2f628ce9c2783a6c}{value}});
231         \}
232         CHECK(values.size() == 1 || values.size() == \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}}) << \textcolor{stringliteral}{"Specify either 1
       mean\_value or as many as channels: "} << \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}};
233 
234         std::vector<cv::Mat> channels;
235         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \mbox{\hyperlink{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}{num\_channels\_}}; ++i)
236         \{
237             \textcolor{comment}{/* Extract an individual channel. */}
238             Mat channel(\mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}}.height, \mbox{\hyperlink{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}{input\_geometry\_}}.width, 
      CV\_32FC1, Scalar(values[i]));
239             channels.push\_back(channel);
240         \}
241 
242         Mat packed\_mean;
243         merge(channels, packed\_mean);
244 
245         \mbox{\hyperlink{class_s_s_d_a3974a4a620cee93f5523c459482887e2}{mean\_}}.upload(packed\_mean);
246     \}
247 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=261pt]{class_s_s_d_ada3debdd0e04185587f13b44a6b63765_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_s_s_d_aec550d5312257216d93955cdee13a73e}\label{class_s_s_d_aec550d5312257216d93955cdee13a73e}} 
\index{S\+SD@{S\+SD}!Wrap\+Input\+Layer@{Wrap\+Input\+Layer}}
\index{Wrap\+Input\+Layer@{Wrap\+Input\+Layer}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{Wrap\+Input\+Layer()}{WrapInputLayer()}}
{\footnotesize\ttfamily void S\+S\+D\+::\+Wrap\+Input\+Layer (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{Gpu\+Mat}} $>$ $\ast$}]{input\+\_\+channels }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 254 of file S\+S\+D.\+cpp.


\begin{DoxyCode}
255 \{
256     Blob<float>* input\_layer = \mbox{\hyperlink{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}{net\_}}->input\_blobs()[0];
257 
258     \textcolor{keywordtype}{int} width = input\_layer->width();
259     \textcolor{keywordtype}{int} height = input\_layer->height();
260     \textcolor{keywordtype}{float}* input\_data = input\_layer->mutable\_gpu\_data();
261     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < input\_layer->channels(); ++i)
262     \{
263         \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{GpuMat}} channel(height, width, CV\_32FC1, input\_data);
264         input\_channels->push\_back(channel);
265         input\_data += width * height;
266     \}
267 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_s_s_d_aec550d5312257216d93955cdee13a73e_icgraph}
\end{center}
\end{figure}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}\label{class_s_s_d_af45a3ca33b8adcb4b2e23ebd23891947}} 
\index{S\+SD@{S\+SD}!allocator\+\_\+@{allocator\+\_\+}}
\index{allocator\+\_\+@{allocator\+\_\+}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{allocator\+\_\+}{allocator\_}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_g_p_u_allocator}{G\+P\+U\+Allocator}}$\ast$ S\+S\+D\+::allocator\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{gpu__allocator_8h}{gpu\+\_\+allocator.\+h}} 
\end{DoxySeeAlso}
\begin{DoxyAuthor}{Author}
Shinung 
\end{DoxyAuthor}


Definition at line 178 of file S\+S\+D.\+h.

\mbox{\Hypertarget{class_s_s_d_a2deab37585140ff74fbec6e54f5407bf}\label{class_s_s_d_a2deab37585140ff74fbec6e54f5407bf}} 
\index{S\+SD@{S\+SD}!conf\+\_\+@{conf\+\_\+}}
\index{conf\+\_\+@{conf\+\_\+}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{conf\+\_\+}{conf\_}}
{\footnotesize\ttfamily float S\+S\+D\+::conf\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 185 of file S\+S\+D.\+h.

\mbox{\Hypertarget{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}\label{class_s_s_d_a3fe828551a5a53a3f43a481ae5d2d96a}} 
\index{S\+SD@{S\+SD}!input\+\_\+geometry\+\_\+@{input\+\_\+geometry\+\_\+}}
\index{input\+\_\+geometry\+\_\+@{input\+\_\+geometry\+\_\+}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{input\+\_\+geometry\+\_\+}{input\_geometry\_}}
{\footnotesize\ttfamily Size S\+S\+D\+::input\+\_\+geometry\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 180 of file S\+S\+D.\+h.

\mbox{\Hypertarget{class_s_s_d_a1c4d34f2dda5d4ca2dfabbebff7a0ddb}\label{class_s_s_d_a1c4d34f2dda5d4ca2dfabbebff7a0ddb}} 
\index{S\+SD@{S\+SD}!labels\+\_\+@{labels\+\_\+}}
\index{labels\+\_\+@{labels\+\_\+}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{labels\+\_\+}{labels\_}}
{\footnotesize\ttfamily std\+::vector$<$std\+::string$>$ S\+S\+D\+::labels\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 183 of file S\+S\+D.\+h.

\mbox{\Hypertarget{class_s_s_d_a3974a4a620cee93f5523c459482887e2}\label{class_s_s_d_a3974a4a620cee93f5523c459482887e2}} 
\index{S\+SD@{S\+SD}!mean\+\_\+@{mean\+\_\+}}
\index{mean\+\_\+@{mean\+\_\+}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{mean\+\_\+}{mean\_}}
{\footnotesize\ttfamily \mbox{\hyperlink{gpu__allocator_8h_aa7700da124206551c0f9d273152f13fb}{Gpu\+Mat}} S\+S\+D\+::mean\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 182 of file S\+S\+D.\+h.

\mbox{\Hypertarget{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}\label{class_s_s_d_a9b70501b85252c3135030e5c6c1e7117}} 
\index{S\+SD@{S\+SD}!net\+\_\+@{net\+\_\+}}
\index{net\+\_\+@{net\+\_\+}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{net\+\_\+}{net\_}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$caffe\+::\+Net$<$float$>$ $>$ S\+S\+D\+::net\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 179 of file S\+S\+D.\+h.

\mbox{\Hypertarget{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}\label{class_s_s_d_affe6f7e948b0040bd958db34758d8ab1}} 
\index{S\+SD@{S\+SD}!num\+\_\+channels\+\_\+@{num\+\_\+channels\+\_\+}}
\index{num\+\_\+channels\+\_\+@{num\+\_\+channels\+\_\+}!S\+SD@{S\+SD}}
\subsubsection{\texorpdfstring{num\+\_\+channels\+\_\+}{num\_channels\_}}
{\footnotesize\ttfamily int S\+S\+D\+::num\+\_\+channels\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 181 of file S\+S\+D.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
D\+:/\+Roy/\+Git\+Hub/\+Multitarget-\/tracker/\+Detector/\mbox{\hyperlink{_s_s_d_8h}{S\+S\+D.\+h}}\item 
D\+:/\+Roy/\+Git\+Hub/\+Multitarget-\/tracker/\+Detector/\mbox{\hyperlink{_s_s_d_8cpp}{S\+S\+D.\+cpp}}\end{DoxyCompactItemize}
