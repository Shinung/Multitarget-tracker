\hypertarget{fheap_8c}{}\section{D\+:/\+Roy/\+Git\+Hub/\+Multitarget-\/tracker/\+Tracker/graph/fheap.c File Reference}
\label{fheap_8c}\index{D\+:/\+Roy/\+Git\+Hub/\+Multitarget-\/tracker/\+Tracker/graph/fheap.\+c@{D\+:/\+Roy/\+Git\+Hub/\+Multitarget-\/tracker/\+Tracker/graph/fheap.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include \char`\"{}fheap.\+h\char`\"{}}\newline
Include dependency graph for fheap.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=260pt]{fheap_8c__incl}
\end{center}
\end{figure}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{fheap_8c_aa1dd92158663cbc7ba3a6520b4e28090}{F\+H\+E\+A\+P\+\_\+\+D\+U\+MP}}~0
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{fheap_8c_aebe49ab32683a4650cb05149f8b7adbe}{fh\+\_\+dump\+\_\+nodes}} (\mbox{\hyperlink{fheap_8h_a287241d6991f4f1027058c066fc7003e}{fheap\+\_\+node\+\_\+t}} $\ast$ptr, int level)
\item 
void \mbox{\hyperlink{fheap_8c_a2477574c1ffd36f746abb612ee03c23c}{fh\+\_\+meld}} (\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$h, \mbox{\hyperlink{fheap_8h_a287241d6991f4f1027058c066fc7003e}{fheap\+\_\+node\+\_\+t}} $\ast$tree\+\_\+list)
\item 
\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$ \mbox{\hyperlink{fheap_8c_a8a4f7ba67a3d47a511e1af128d59f7cb}{fh\+\_\+alloc}} (int max\+\_\+nodes)
\item 
void \mbox{\hyperlink{fheap_8c_a11e6d24701acd9d4f1ffc8652dcfa340}{fh\+\_\+free}} (\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$h)
\item 
void \mbox{\hyperlink{fheap_8c_a4489cad6a8830374aaa7db8705d222a1}{fh\+\_\+insert}} (\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$h, int vertex\+\_\+no, long k)
\item 
int \mbox{\hyperlink{fheap_8c_a1103efc45c2f1814139914353e684f1a}{fh\+\_\+delete\+\_\+min}} (\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$h)
\item 
void \mbox{\hyperlink{fheap_8c_aae5cdb4b5c64bb4597d36eb36d3d2c4b}{fh\+\_\+decrease\+\_\+key}} (\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$h, int vertex\+\_\+no, long new\+\_\+value)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Fibonacci heap 

\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{fheap_8c_aa1dd92158663cbc7ba3a6520b4e28090}\label{fheap_8c_aa1dd92158663cbc7ba3a6520b4e28090}} 
\index{fheap.\+c@{fheap.\+c}!F\+H\+E\+A\+P\+\_\+\+D\+U\+MP@{F\+H\+E\+A\+P\+\_\+\+D\+U\+MP}}
\index{F\+H\+E\+A\+P\+\_\+\+D\+U\+MP@{F\+H\+E\+A\+P\+\_\+\+D\+U\+MP}!fheap.\+c@{fheap.\+c}}
\subsubsection{\texorpdfstring{F\+H\+E\+A\+P\+\_\+\+D\+U\+MP}{FHEAP\_DUMP}}
{\footnotesize\ttfamily \#define F\+H\+E\+A\+P\+\_\+\+D\+U\+MP~0}



Definition at line 419 of file fheap.\+c.



\subsection{Function Documentation}
\mbox{\Hypertarget{fheap_8c_a8a4f7ba67a3d47a511e1af128d59f7cb}\label{fheap_8c_a8a4f7ba67a3d47a511e1af128d59f7cb}} 
\index{fheap.\+c@{fheap.\+c}!fh\+\_\+alloc@{fh\+\_\+alloc}}
\index{fh\+\_\+alloc@{fh\+\_\+alloc}!fheap.\+c@{fheap.\+c}}
\subsubsection{\texorpdfstring{fh\+\_\+alloc()}{fh\_alloc()}}
{\footnotesize\ttfamily \mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}}$\ast$ fh\+\_\+alloc (\begin{DoxyParamCaption}\item[{int}]{max\+\_\+nodes }\end{DoxyParamCaption})}



Definition at line 44 of file fheap.\+c.


\begin{DoxyCode}
45 \{
46     \mbox{\hyperlink{structfheap}{fheap\_t}} *h;
47 \textcolor{preprocessor}{#if FHEAP\_DUMP}
48 printf(\textcolor{stringliteral}{"alloc, "});
49 \textcolor{preprocessor}{#endif}
50  
51     \textcolor{comment}{/* Create the heap. */}
52     h = (\mbox{\hyperlink{structfheap}{fheap\_t}} *)malloc(\textcolor{keyword}{sizeof}(\mbox{\hyperlink{structfheap}{fheap\_t}}));
53  
54     h->\mbox{\hyperlink{structfheap_a496e0271cc82f25d8c53588b7982954b}{max\_trees}} = (int)(1.0 + 1.44 * log(max\_nodes)/log(2.0));
55     h->\mbox{\hyperlink{structfheap_a05a5bfb7e168b7aacb49e998a87f4d6f}{max\_nodes}} = max\_nodes;
56     h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}} = (\mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} **)calloc(h->\mbox{\hyperlink{structfheap_a496e0271cc82f25d8c53588b7982954b}{max\_trees}}, \textcolor{keyword}{sizeof}(
      \mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} *));
57     h->\mbox{\hyperlink{structfheap_ab78171d6b052efe35f0ff7f6d9fd8f99}{nodes}} = (\mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} **)calloc(max\_nodes, \textcolor{keyword}{sizeof}(
      \mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} *));
58     h->\mbox{\hyperlink{structfheap_af369ea8f1202800c582fe570803fea9f}{n}} = 0;
59 
60     \textcolor{comment}{/* The value of the heap helps to keep track of the maximum rank while}
61 \textcolor{comment}{     * nodes are inserted or deleted.}
62 \textcolor{comment}{     */}
63     h->\mbox{\hyperlink{structfheap_a04d7238a058ccbd0beb8e807d212f348}{value}} = 0;
64 
65     \textcolor{comment}{/* For experimental purposes, we keep a count of the number of key}
66 \textcolor{comment}{     * comparisons.}
67 \textcolor{comment}{     */}
68     h->\mbox{\hyperlink{structfheap_ab593aa07617376fafd3d1c378d5d73d9}{key\_comps}} = 0;
69 
70 \textcolor{preprocessor}{#if FHEAP\_DUMP}
71 printf(\textcolor{stringliteral}{"alloc-exited, "});
72 \textcolor{preprocessor}{#endif}
73     \textcolor{keywordflow}{return} h; 
74 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{fheap_8c_a8a4f7ba67a3d47a511e1af128d59f7cb_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{fheap_8c_aae5cdb4b5c64bb4597d36eb36d3d2c4b}\label{fheap_8c_aae5cdb4b5c64bb4597d36eb36d3d2c4b}} 
\index{fheap.\+c@{fheap.\+c}!fh\+\_\+decrease\+\_\+key@{fh\+\_\+decrease\+\_\+key}}
\index{fh\+\_\+decrease\+\_\+key@{fh\+\_\+decrease\+\_\+key}!fheap.\+c@{fheap.\+c}}
\subsubsection{\texorpdfstring{fh\+\_\+decrease\+\_\+key()}{fh\_decrease\_key()}}
{\footnotesize\ttfamily void fh\+\_\+decrease\+\_\+key (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$}]{h,  }\item[{int}]{vertex\+\_\+no,  }\item[{long}]{new\+\_\+value }\end{DoxyParamCaption})}



Definition at line 199 of file fheap.\+c.


\begin{DoxyCode}
200 \{
201     \mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} *cut\_node, *parent, *new\_roots, *r, *l;
202     \textcolor{keywordtype}{int} prev\_rank;
203 
204 \textcolor{preprocessor}{#if FHEAP\_DUMP}
205 printf(\textcolor{stringliteral}{"decrease\_key on vn = %d, "}, vertex\_no);
206 \textcolor{preprocessor}{#endif}
207 
208     \textcolor{comment}{/* Obtain a pointer to the decreased node and its parent then decrease the}
209 \textcolor{comment}{     * nodes key.}
210 \textcolor{comment}{     */}
211     cut\_node = h->\mbox{\hyperlink{structfheap_ab78171d6b052efe35f0ff7f6d9fd8f99}{nodes}}[vertex\_no];
212     parent = cut\_node->\mbox{\hyperlink{structfheap__node_a3dc01ed7a15e3eeb6971acf9c1d63e2f}{parent}};
213     cut\_node->\mbox{\hyperlink{structfheap__node_ae5b8eaa56de8c3e43b958bcc9c46a8e3}{key}} = new\_value;
214 
215     \textcolor{comment}{/* No reinsertion occurs if the node changed was a root. */}
216     \textcolor{keywordflow}{if}(!parent) \{
217 \textcolor{preprocessor}{#if FHEAP\_DUMP}
218 printf(\textcolor{stringliteral}{"decrease\_key-exited, "});
219 \textcolor{preprocessor}{#endif}
220         \textcolor{keywordflow}{return};
221     \}
222 
223     \textcolor{comment}{/* Update the left and right pointers of cut\_node and its two neighbouring}
224 \textcolor{comment}{     * nodes.}
225 \textcolor{comment}{     */}
226     l = cut\_node->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}};
227     r = cut\_node->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}};
228     l->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = r;
229     r->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = l;
230     cut\_node->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = cut\_node->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = cut\_node;
231 
232     \textcolor{comment}{/* Initially the list of new roots contains only one node. */}
233     new\_roots = cut\_node;
234 
235     \textcolor{comment}{/* While there is a parent node that is marked a cascading cut occurs. */}
236     \textcolor{keywordflow}{while}(parent && parent->\mbox{\hyperlink{structfheap__node_a157ede2cfd1f97c4b71e6eaf91537b56}{marked}}) \{
237 
238         \textcolor{comment}{/* Decrease the rank of cut\_node's parent an update its child pointer.}
239 \textcolor{comment}{         */}
240         parent->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}}--;
241         \textcolor{keywordflow}{if}(parent->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}}) \{
242             \textcolor{keywordflow}{if}(parent->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}} == cut\_node) parent->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}} = r;
243         \}
244         \textcolor{keywordflow}{else} \{
245             parent->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}} = NULL;
246         \}
247 
248         \textcolor{comment}{/* Update the cut\_node and parent pointers to the parent. */}
249         cut\_node = parent;
250         parent = cut\_node->\mbox{\hyperlink{structfheap__node_a3dc01ed7a15e3eeb6971acf9c1d63e2f}{parent}};
251 
252         \textcolor{comment}{/* Update the left and right pointers of cut\_nodes two neighbouring}
253 \textcolor{comment}{         * nodes.}
254 \textcolor{comment}{         */}
255         l = cut\_node->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}};
256         r = cut\_node->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}};
257         l->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = r;
258         r->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = l;
259 
260         \textcolor{comment}{/* Add cut\_node to the list of nodes to be reinserted as new roots. */}
261         l = new\_roots->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}};
262         new\_roots->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = l->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = cut\_node;
263         cut\_node->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = l;
264         cut\_node->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = new\_roots;
265         new\_roots = cut\_node;
266     \}
267 
268     \textcolor{comment}{/* If the root node is being relocated then update the trees[] array.}
269 \textcolor{comment}{     * Otherwise mark the parent of the last node cut.}
270 \textcolor{comment}{     */}
271     \textcolor{keywordflow}{if}(!parent) \{
272         prev\_rank = cut\_node->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}} + 1;
273         h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}}[prev\_rank] = NULL;
274         h->\mbox{\hyperlink{structfheap_a04d7238a058ccbd0beb8e807d212f348}{value}} -= (1 << prev\_rank);
275     \}
276     \textcolor{keywordflow}{else} \{
277         \textcolor{comment}{/* Decrease the rank of cut\_node's parent an update its child pointer.}
278 \textcolor{comment}{         */}
279         parent->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}}--;
280         \textcolor{keywordflow}{if}(parent->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}}) \{
281             \textcolor{keywordflow}{if}(parent->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}} == cut\_node) parent->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}} = r;
282         \}
283         \textcolor{keywordflow}{else} \{
284             parent->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}} = NULL;
285         \}
286 
287         parent->\mbox{\hyperlink{structfheap__node_a157ede2cfd1f97c4b71e6eaf91537b56}{marked}} = 1;
288     \}
289 
290     \textcolor{comment}{/* Meld the new roots into the heap. */}
291     \mbox{\hyperlink{fheap_8c_a2477574c1ffd36f746abb612ee03c23c}{fh\_meld}}(h, new\_roots);
292 
293 \textcolor{preprocessor}{#if FHEAP\_DUMP}
294 printf(\textcolor{stringliteral}{"decrease\_key-exited, "});
295 \textcolor{preprocessor}{#endif}
296 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{fheap_8c_aae5cdb4b5c64bb4597d36eb36d3d2c4b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{fheap_8c_aae5cdb4b5c64bb4597d36eb36d3d2c4b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{fheap_8c_a1103efc45c2f1814139914353e684f1a}\label{fheap_8c_a1103efc45c2f1814139914353e684f1a}} 
\index{fheap.\+c@{fheap.\+c}!fh\+\_\+delete\+\_\+min@{fh\+\_\+delete\+\_\+min}}
\index{fh\+\_\+delete\+\_\+min@{fh\+\_\+delete\+\_\+min}!fheap.\+c@{fheap.\+c}}
\subsubsection{\texorpdfstring{fh\+\_\+delete\+\_\+min()}{fh\_delete\_min()}}
{\footnotesize\ttfamily int fh\+\_\+delete\+\_\+min (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$}]{h }\end{DoxyParamCaption})}



Definition at line 139 of file fheap.\+c.


\begin{DoxyCode}
140 \{
141     \mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} *min\_node, *child, *next;
142     \textcolor{keywordtype}{long} k, k2;
143     \textcolor{keywordtype}{int} r, v, vertex\_no;
144 
145 \textcolor{preprocessor}{#if FHEAP\_DUMP}
146 printf(\textcolor{stringliteral}{"delete\_min, "});
147 \textcolor{preprocessor}{#endif}
148 
149     \textcolor{comment}{/* First we determine the maximum rank in the heap. */}
150     v = h->\mbox{\hyperlink{structfheap_a04d7238a058ccbd0beb8e807d212f348}{value}};
151     r = -1;
152     \textcolor{keywordflow}{while}(v) \{
153         v = v >> 1;
154         r++;
155     \};
156 
157     \textcolor{comment}{/* Now determine which root node is the minimum. */}
158     min\_node = h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}}[r];
159     k = min\_node->\mbox{\hyperlink{structfheap__node_ae5b8eaa56de8c3e43b958bcc9c46a8e3}{key}};
160     \textcolor{keywordflow}{while}(r > 0) \{
161         r--;
162         next = h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}}[r];
163         \textcolor{keywordflow}{if}(next) \{
164             \textcolor{keywordflow}{if}((k2 = next->\mbox{\hyperlink{structfheap__node_ae5b8eaa56de8c3e43b958bcc9c46a8e3}{key}}) < k) \{
165                 k = k2;
166                 min\_node = next;
167             \}
168             h->\mbox{\hyperlink{structfheap_ab593aa07617376fafd3d1c378d5d73d9}{key\_comps}}++;
169         \}
170     \}
171 
172     \textcolor{comment}{/* We remove the minimum node from the heap but keep a pointer to it. */}
173     r = min\_node->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}};
174     h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}}[r] = NULL;
175     h->\mbox{\hyperlink{structfheap_a04d7238a058ccbd0beb8e807d212f348}{value}} -= (1 << r);
176 
177     child = min\_node->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}};
178     \textcolor{keywordflow}{if}(child) \mbox{\hyperlink{fheap_8c_a2477574c1ffd36f746abb612ee03c23c}{fh\_meld}}(h, child);
179 
180     \textcolor{comment}{/* Record the vertex no of the old minimum node before deleting it. */}
181     vertex\_no = min\_node->\mbox{\hyperlink{structfheap__node_a830c8feb141fe01db7e4cfab6396ae0d}{vertex\_no}};
182     h->\mbox{\hyperlink{structfheap_ab78171d6b052efe35f0ff7f6d9fd8f99}{nodes}}[vertex\_no] = NULL;
183     free(min\_node);
184     h->\mbox{\hyperlink{structfheap_af369ea8f1202800c582fe570803fea9f}{n}}--;
185 
186 \textcolor{preprocessor}{#if FHEAP\_DUMP}
187 printf(\textcolor{stringliteral}{"delete\_min-exited, "});
188 \textcolor{preprocessor}{#endif}
189 
190     \textcolor{keywordflow}{return} vertex\_no;
191 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=243pt]{fheap_8c_a1103efc45c2f1814139914353e684f1a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{fheap_8c_a1103efc45c2f1814139914353e684f1a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{fheap_8c_aebe49ab32683a4650cb05149f8b7adbe}\label{fheap_8c_aebe49ab32683a4650cb05149f8b7adbe}} 
\index{fheap.\+c@{fheap.\+c}!fh\+\_\+dump\+\_\+nodes@{fh\+\_\+dump\+\_\+nodes}}
\index{fh\+\_\+dump\+\_\+nodes@{fh\+\_\+dump\+\_\+nodes}!fheap.\+c@{fheap.\+c}}
\subsubsection{\texorpdfstring{fh\+\_\+dump\+\_\+nodes()}{fh\_dump\_nodes()}}
{\footnotesize\ttfamily void fh\+\_\+dump\+\_\+nodes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{fheap_8h_a287241d6991f4f1027058c066fc7003e}{fheap\+\_\+node\+\_\+t}} $\ast$}]{ptr,  }\item[{int}]{level }\end{DoxyParamCaption})}

\mbox{\Hypertarget{fheap_8c_a11e6d24701acd9d4f1ffc8652dcfa340}\label{fheap_8c_a11e6d24701acd9d4f1ffc8652dcfa340}} 
\index{fheap.\+c@{fheap.\+c}!fh\+\_\+free@{fh\+\_\+free}}
\index{fh\+\_\+free@{fh\+\_\+free}!fheap.\+c@{fheap.\+c}}
\subsubsection{\texorpdfstring{fh\+\_\+free()}{fh\_free()}}
{\footnotesize\ttfamily void fh\+\_\+free (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$}]{h }\end{DoxyParamCaption})}



Definition at line 80 of file fheap.\+c.


\begin{DoxyCode}
81 \{
82     \textcolor{keywordtype}{int} i;
83     
84 \textcolor{preprocessor}{#if FHEAP\_DUMP}
85 printf(\textcolor{stringliteral}{"free, "});
86 \textcolor{preprocessor}{#endif}
87 
88     \textcolor{keywordflow}{for}(i = 0; i < h->\mbox{\hyperlink{structfheap_a05a5bfb7e168b7aacb49e998a87f4d6f}{max\_nodes}}; i++) \{
89         free(h->\mbox{\hyperlink{structfheap_ab78171d6b052efe35f0ff7f6d9fd8f99}{nodes}}[i]);
90     \}
91 
92     free(h->\mbox{\hyperlink{structfheap_ab78171d6b052efe35f0ff7f6d9fd8f99}{nodes}});
93     free(h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}});
94     free(h);
95     
96 \textcolor{preprocessor}{#if FHEAP\_DUMP}
97 printf(\textcolor{stringliteral}{"free-exited, "});
98 \textcolor{preprocessor}{#endif}
99 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{fheap_8c_a11e6d24701acd9d4f1ffc8652dcfa340_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{fheap_8c_a4489cad6a8830374aaa7db8705d222a1}\label{fheap_8c_a4489cad6a8830374aaa7db8705d222a1}} 
\index{fheap.\+c@{fheap.\+c}!fh\+\_\+insert@{fh\+\_\+insert}}
\index{fh\+\_\+insert@{fh\+\_\+insert}!fheap.\+c@{fheap.\+c}}
\subsubsection{\texorpdfstring{fh\+\_\+insert()}{fh\_insert()}}
{\footnotesize\ttfamily void fh\+\_\+insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$}]{h,  }\item[{int}]{vertex\+\_\+no,  }\item[{long}]{k }\end{DoxyParamCaption})}



Definition at line 105 of file fheap.\+c.


\begin{DoxyCode}
106 \{
107     \mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} *newn;
108 
109 \textcolor{preprocessor}{#if FHEAP\_DUMP}
110 printf(\textcolor{stringliteral}{"insert, "});
111 \textcolor{preprocessor}{#endif}
112 
113     \textcolor{comment}{/* Create an initialise the new node. */}
114     newn = (\mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} *)malloc(\textcolor{keyword}{sizeof}(\mbox{\hyperlink{structfheap__node}{fheap\_node\_t}}));
115     newn->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}} = NULL;
116     newn->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = newn->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = newn;
117     newn->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}} = 0;
118     newn->\mbox{\hyperlink{structfheap__node_a830c8feb141fe01db7e4cfab6396ae0d}{vertex\_no}} = vertex\_no;
119     newn->\mbox{\hyperlink{structfheap__node_ae5b8eaa56de8c3e43b958bcc9c46a8e3}{key}} = k;
120 
121     \textcolor{comment}{/* Maintain a pointer vertex\_no's new node in the heap. */}
122     h->\mbox{\hyperlink{structfheap_ab78171d6b052efe35f0ff7f6d9fd8f99}{nodes}}[vertex\_no] = newn;
123 
124     \textcolor{comment}{/* Meld the new node into the heap. */}
125     \mbox{\hyperlink{fheap_8c_a2477574c1ffd36f746abb612ee03c23c}{fh\_meld}}(h, newn);
126 
127     \textcolor{comment}{/* Update the heaps node count. */}
128     h->\mbox{\hyperlink{structfheap_af369ea8f1202800c582fe570803fea9f}{n}}++;
129 
130 \textcolor{preprocessor}{#if FHEAP\_DUMP}
131 printf(\textcolor{stringliteral}{"insert-exited, "});
132 \textcolor{preprocessor}{#endif}
133 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=219pt]{fheap_8c_a4489cad6a8830374aaa7db8705d222a1_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{fheap_8c_a4489cad6a8830374aaa7db8705d222a1_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{fheap_8c_a2477574c1ffd36f746abb612ee03c23c}\label{fheap_8c_a2477574c1ffd36f746abb612ee03c23c}} 
\index{fheap.\+c@{fheap.\+c}!fh\+\_\+meld@{fh\+\_\+meld}}
\index{fh\+\_\+meld@{fh\+\_\+meld}!fheap.\+c@{fheap.\+c}}
\subsubsection{\texorpdfstring{fh\+\_\+meld()}{fh\_meld()}}
{\footnotesize\ttfamily void fh\+\_\+meld (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{fheap_8h_a81491fcb8cde3f99611815852e42a9ad}{fheap\+\_\+t}} $\ast$}]{h,  }\item[{\mbox{\hyperlink{fheap_8h_a287241d6991f4f1027058c066fc7003e}{fheap\+\_\+node\+\_\+t}} $\ast$}]{tree\+\_\+list }\end{DoxyParamCaption})}



Definition at line 305 of file fheap.\+c.


\begin{DoxyCode}
306 \{
307     \mbox{\hyperlink{structfheap__node}{fheap\_node\_t}} *first, *next, *node\_ptr, *new\_root, *temp, *temp2, *lc, *rc;
308     \textcolor{keywordtype}{int} r;
309 
310 \textcolor{preprocessor}{#if FHEAP\_DUMP}
311 printf(\textcolor{stringliteral}{"meld: "});
312 \textcolor{preprocessor}{#endif}
313 
314     \textcolor{comment}{/* We meld each tree in the circularly linked list back into the root level}
315 \textcolor{comment}{     * of the heap.  Each node in the linked list is the root node of a tree.}
316 \textcolor{comment}{     * The circularly linked list uses the sibling pointers of nodes.  This}
317 \textcolor{comment}{     *  makes melding of the child nodes from a delete\_min operation simple.}
318 \textcolor{comment}{     */}
319     node\_ptr = first = tree\_list;
320 
321     \textcolor{keywordflow}{do} \{
322 
323 \textcolor{preprocessor}{#if FHEAP\_DUMP}
324 printf(\textcolor{stringliteral}{"%d, "}, node\_ptr->\mbox{\hyperlink{structfheap__node_a830c8feb141fe01db7e4cfab6396ae0d}{vertex\_no}});
325 \textcolor{preprocessor}{#endif}
326 
327         \textcolor{comment}{/* Keep a pointer to the next node and remove sibling and parent links}
328 \textcolor{comment}{         * from the current node.  node\_ptr points to the current node.}
329 \textcolor{comment}{         */}
330         next = node\_ptr->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}};
331         node\_ptr->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = node\_ptr->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = node\_ptr;
332         node\_ptr->\mbox{\hyperlink{structfheap__node_a3dc01ed7a15e3eeb6971acf9c1d63e2f}{parent}} = NULL;
333 
334         \textcolor{comment}{/* We merge the current node, node\_ptr, by inserting it into the}
335 \textcolor{comment}{         * root level of the heap.}
336 \textcolor{comment}{         */}
337         new\_root = node\_ptr;
338         r = node\_ptr->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}};
339 
340         \textcolor{comment}{/* This loop inserts the new root into the heap, possibly restructuring}
341 \textcolor{comment}{         * the heap to ensure that only one tree for each degree exists.}
342 \textcolor{comment}{         */}
343         \textcolor{keywordflow}{do} \{
344 
345             \textcolor{comment}{/* Check if there is already a tree of degree r in the heap.}
346 \textcolor{comment}{             * If there is then we need to link it with new\_root so it will be}
347 \textcolor{comment}{             * reinserted into a new place in the heap.}
348 \textcolor{comment}{             */}
349             \textcolor{keywordflow}{if}((temp = h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}}[r])) \{
350 
351             \textcolor{comment}{/* temp will be linked to new\_root and relocated so we no}
352 \textcolor{comment}{                 * longer will have a tree of degree r.}
353 \textcolor{comment}{                 */}
354                 h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}}[r] = NULL;
355                 h->\mbox{\hyperlink{structfheap_a04d7238a058ccbd0beb8e807d212f348}{value}} -= (1 << r);
356 
357             \textcolor{comment}{/* Swap temp and new\_root if necessary so that new\_root always}
358 \textcolor{comment}{                 * points to the root node which has the smaller key of the}
359 \textcolor{comment}{                 * two.}
360 \textcolor{comment}{                 */}
361             \textcolor{keywordflow}{if}(temp->\mbox{\hyperlink{structfheap__node_ae5b8eaa56de8c3e43b958bcc9c46a8e3}{key}} < new\_root->\mbox{\hyperlink{structfheap__node_ae5b8eaa56de8c3e43b958bcc9c46a8e3}{key}}) \{
362                     temp2 = new\_root;
363                     new\_root = temp;
364                     temp = temp2;
365                 \}
366                 h->\mbox{\hyperlink{structfheap_ab593aa07617376fafd3d1c378d5d73d9}{key\_comps}}++;
367 
368                 \textcolor{comment}{/* Link temp with new\_root, making sure that sibling pointers}
369 \textcolor{comment}{                 * get updated if rank is greater than 0.  Also, increase r for}
370 \textcolor{comment}{                 * the next pass through the loop since the rank of new has}
371 \textcolor{comment}{                 * increased.}
372 \textcolor{comment}{                 */}
373             \textcolor{keywordflow}{if}(r++ > 0) \{
374                     rc = new\_root->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}};
375                     lc = rc->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}};
376                     temp->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = lc;
377                     temp->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = rc;
378                     lc->\mbox{\hyperlink{structfheap__node_af83e42765eddab9c0288352be54fe907}{right}} = rc->\mbox{\hyperlink{structfheap__node_a714c50b04c29981fa46b7c937b328708}{left}} = temp;
379                 \}
380                 new\_root->\mbox{\hyperlink{structfheap__node_a5c0411a8c1b8e4712852691605484f80}{child}} = temp;
381                 new\_root->\mbox{\hyperlink{structfheap__node_a6e8d65cbe58c9646f5bc2a308f147343}{rank}} = r;
382                 temp->\mbox{\hyperlink{structfheap__node_a3dc01ed7a15e3eeb6971acf9c1d63e2f}{parent}} = new\_root;
383                 temp->\mbox{\hyperlink{structfheap__node_a157ede2cfd1f97c4b71e6eaf91537b56}{marked}} = 0;
384             \}
385             \textcolor{comment}{/* Otherwise if there is not a tree of degree r in the heap we}
386 \textcolor{comment}{             * allow new\_root, which possibly carries moved trees in the heap,}
387 \textcolor{comment}{             * to be a tree of degree r in the heap.}
388 \textcolor{comment}{             */}
389             \textcolor{keywordflow}{else} \{
390 
391                 h->\mbox{\hyperlink{structfheap_afc06f9768708fb48c24e7a788c108fb7}{trees}}[r] = new\_root;
392                 h->\mbox{\hyperlink{structfheap_a04d7238a058ccbd0beb8e807d212f348}{value}} += (1 << r);;
393 
394                 \textcolor{comment}{/* NOTE:  Because new\_root is now a root we ensure it is}
395 \textcolor{comment}{                 *        marked.}
396 \textcolor{comment}{                 */}
397                 new\_root->\mbox{\hyperlink{structfheap__node_a157ede2cfd1f97c4b71e6eaf91537b56}{marked}} = 1;
398         \}
399 
400             \textcolor{comment}{/* Note that temp will be NULL if and only if there was not a tree}
401 \textcolor{comment}{             * of degree r.}
402 \textcolor{comment}{             */}
403         \} \textcolor{keywordflow}{while}(temp);
404 
405         node\_ptr = next;
406 
407     \} \textcolor{keywordflow}{while}(node\_ptr != first);
408 
409 \textcolor{preprocessor}{#if FHEAP\_DUMP}
410 printf(\textcolor{stringliteral}{"meld-exited, "});
411 \textcolor{preprocessor}{#endif}
412 \}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{fheap_8c_a2477574c1ffd36f746abb612ee03c23c_icgraph}
\end{center}
\end{figure}
